# 工作原理

**如果启用了幂等生产者，那么**<mark style="color:blue;">**每条消息都将包含生产者ID(PID)和序列号，将它们与目标主题和分区组合在一起，用于唯一标识一条消息**</mark>。**broker会用这些唯一标识符跟踪写入每个分区的**<mark style="color:blue;">**最后5条消息**</mark>**。**<mark style="color:orange;">**为了减少每个分区需要跟踪的序列号数量，生产者需要将max.inflight.requests设置成5或更小的值（默认值是5）。**</mark>

**如果broker收到之前已经收到过的消息，那么它将拒绝这条消息，并返回错误。**生产者会记录这个错误，并反映在指标当中，但不抛出异常，也不触发告警。

* 在生产者客户端，错误将被添加到record-error-rate指标当中。
* 在broker端，错误是ErrorsPerSec指标的一部分。

如果broker收到一个非常大的序列号该怎么办？如果broker期望消息2后面跟着消息3，但收到了消息27，那么这个时候该怎么办？在这种情况下，broker将返回**“乱序”**错误。如果使用了不带事务的幂等生产者，则这个错误可能会被忽略。

## **生产者重启**

当一个生产者发生故障时，我们通常会创建新生产者来代替它，如果启用了幂等生产者，那么**生产者在重启时就会连接broker并生成生产者ID**。

生产者在每次初始化时都会产生一个新ID（假设没有启用事务）。**这意味着如果一个生产者发生故障，取代它的生产者发送了一条旧生产者已经发送过的消息，那么broker将无法检测到重复，因为这两条消息有不同的生产者ID和序列号，将被视为两条不同的消息。**

需要注意的是，如果一个旧生产者被挂起，但在替代它的新生产者启动之后又“活”过来了，那么情况也一样——旧生产者不会被认为是“僵尸”，它们是两个拥有不同ID的生产者。

## **broker故障**

**当一个broker发生故障时，控制器将为首领副本位于这个broker上的分区选举新首领。**每次生成新消息时，首领都会用最后5个序列号更新内存中的生产者状态。每次从首领复制新消息时，跟随者副本都会更新自己的内存。当跟随者成为新首领时，它的内存中已经有了最新的序列号，并且可以继续验证新生成的消息，不会有任何问题或延迟。

*   [x] 如果旧首领又“活”过来了，会发生什么呢？

    在重启之后，内存中没有旧首领的生产者状态。为了能够恢复状态，每次在关闭或创建日志片段时 broker都会将生产者状态快照保存到文件中。broker在启动时会从快照文件中读取最新状态，然后通过复制当前首领来更新生产者状态。当它准备好再次成为首领时，内存中已经有了最新的序列号。
*   [x] 如果broker发生崩溃，但没有更新最后一个快照，会发生什么呢？

    生产者ID和序列号也是Kafka消息格式的一部分。在进行故障恢复时，我们将通过读取旧快照和分区最新日志片段里的消息来恢复生产者状态。等故障恢复完成，一个新的快照就保存好了。
*   [x] 如果分区里没有消息，会发生什么呢？

    没有消息也就意味着没有重复消息。我们可以立即开始接收新消息（同时将状态缺失的警告信息记录下来），并创建生产者状态。
