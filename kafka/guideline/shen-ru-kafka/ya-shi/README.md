# 压实

一般情况下，Kafka会根据设置的时间来保留数据，把超过时效的旧数据删除。

* **如果保留策略是**<mark style="color:blue;">**delete**</mark>**，那么早于保留时间的旧事件将被删除；**
* **如果保留策略是**<mark style="color:blue;">**compact**</mark>**（压实），那么只为每个键保留最新的值**。很显然，**只有当应用程序生成的事件里包含了键–值对时，设置compact才有意义**。如果主题中包含了null键，那么这个策略就会失效。

> 主题的数据保留策略也可以被设置成<mark style="color:blue;">**delete.and.compact**</mark>，也就是以上两种策略的组合。**超过保留时间的消息将被删除，即使它们的键对应的值是最新的**。
>
> **组合策略可以防止压实主题变得太大，同时也可以满足业务需要在一段时间后删除数据的要求。**

## 压实的工作原理



## 5.4.2 删除键

<mark style="color:orange;">**要彻底把一个键从系统中删除，应用程序必须发送包含这个键且值为null的消息**</mark>。压实线程在发现这条消息时，会先进行常规的压实操作，只保留值为null的消息。这条消息（被称为**墓碑消息**）会根据配置的参数保留一段时间。在此期间，消费者可以读取到这条消息，并且发现它的值已经被置空。消费者在将Kafka数据复制到关系数据库时，如果它看到这条墓碑消息，就知道应该要把相关的用户信息从数据库中删除。在超过保留期限之后，清理线程会移除墓碑消息，它们的键也将从Kafka分区中消失。这里的关键是要让消费者有足够的时间看到墓碑消息，因为如果消费者离线几小时，那么可能就错过了墓碑消息，也就不会去删除数据库中的相关数据了。

{% hint style="info" %}
值得一提的是，**Kafka的管理客户端提供了一个**<mark style="color:blue;">**deleteRecords**</mark>**方法。这个方法可用于**<mark style="color:blue;">**删除指定偏移量之前的所有记录**</mark>，但它使用的是一种完全不同的机制。当这个方法被调用时，Kafka会将低水位标记（分区的第一个偏移量）移动到指定的偏移量。这样可以防止消费者读取低水位标记之前的记录，保证这些记录在被清理线程删除之前都是不可访问的。这个方法可用于删除设置了保留策略的主题和压实主题。
{% endhint %}

## 5.4.3 何时会压实主题

就像delete策略不会删除当前的活动片段一样，<mark style="color:blue;">**compact策略也不会压实当前的活动片段**</mark>，只有旧片段里的消息才会被压实。

**在默认情况下，Kafka会在主题中有50%的数据包含脏记录的情况下进行压实**。这样做的目的是避免压实太过频繁（因为压实会影响主题的读写性能），同时也能避免存在太多脏记录（因为它们会占用磁盘空间）。

管理员可以通过两个配置参数来控制压实时间：

* **min.compaction.lag.ms**：用于确保消息被写入之后最短需要经过多长时间才可以被压实。
*   **max.compaction.lag.ms**：用于确保消息从写入到可以被压实最长可以是多长时间。当业务要求在一定时间内进行压实时可以使用这个参数，例如，GDPR要求在收到删除请求之后30天内删除某些信息。

