# 5.4 压实

一般情况下，Kafka会根据设置的时间来保留数据，把超过时效的旧数据删除。

* **如果保留策略是**<mark style="color:blue;">**delete**</mark>**，那么早于保留时间的旧事件将被删除；**
* **如果保留策略是**<mark style="color:blue;">**compact**</mark>**（压实），那么只为每个键保留最新的值**。很显然，**只有当应用程序生成的事件里包含了键–值对时，设置compact才有意义**。如果主题中包含了null键，那么这个策略就会失效。

主题的数据保留策略也可以被设置成<mark style="color:blue;">**delete.and.compact**</mark>，也就是以上两种策略的组合。**超过保留时间的消息将被删除，即使它们的键对应的值是最新的**。组合策略可以防止压实主题变得太大，同时也可以满足业务需要在一段时间后删除数据的要求。

## 5.4.1 压实的工作原理：

每个日志片段可以分为以下两个部分：

* **干净的部分**：这些消息之前被压实过，每个键只有一个对应的值，这个值是上一次压实时保留下来的。
* **浑浊的部分**：这些消息是在上一次压实之后写入的。

如果启用了压实功能（通过配置**log.cleaner.enabled**参数来开启），那么broker在启动时会创建一个**压实管理器线程**和一些**压实工作线程**来执行压实任务。这些线程会选择**浑浊率**（浑浊的消息占分区总体消息的比例）最高的分区来压实。

为了压实分区，压实线程会读取分区的浑浊部分，并在内存中创建一个map。map的每个元素都包含消息键的哈希值（16字节）和上一条具有相同键的消息的偏移量（8字节）。Kafka管理员可以配置压实线程在执行压实时可以为map分配多少内存。每个线程都会创建自己的map，但这个参数指的是所有线程可使用的内存总大小。如果你为map分配了1 GB内存，并使用了5个压实线程，那么每个线程将可以使用200 MB内存。**Kafka不要求这个map可以放下整个分区的浑浊部分，但至少要能够放下一个片段的浑浊部分，否则Kafka会报错。**管理员要么为map分配更多的内存，要么减少压实线程数量。如果有几个片段都可以被放进map，那么Kafka将从最旧的片段开始压实，其他片段则继续保持浑浊，等待下一轮压实。

在创建好map后，压实线程会开始从干净的片段读取消息，它会先读取最旧的消息，把它们的内容与map中的内容进行比对。对于每一条消息，它会检查消息的键是否存在于map中，如果不存在，则说明这条消息的值是最新的，就把它复制到替换片段上。如果键已存在，就忽略这条消息，因为后面会有一条更新的包含相同键的消息。在复制完所有消息后，将替换片段与原始片段进行交换，然后开始压实下一个片段。完成整个压实过程后，每一个键对应一条消息，这些消息的值都是最新的。

## 5.4.2 删除键

<mark style="color:orange;">**要彻底把一个键从系统中删除，应用程序必须发送包含这个键且值为null的消息**</mark>。压实线程在发现这条消息时，会先进行常规的压实操作，只保留值为null的消息。这条消息（被称为**墓碑消息**）会根据配置的参数保留一段时间。在此期间，消费者可以读取到这条消息，并且发现它的值已经被置空。消费者在将Kafka数据复制到关系数据库时，如果它看到这条墓碑消息，就知道应该要把相关的用户信息从数据库中删除。在超过保留期限之后，清理线程会移除墓碑消息，它们的键也将从Kafka分区中消失。这里的关键是要让消费者有足够的时间看到墓碑消息，因为如果消费者离线几小时，那么可能就错过了墓碑消息，也就不会去删除数据库中的相关数据了。

{% hint style="info" %}
值得一提的是，**Kafka的管理客户端提供了一个**<mark style="color:blue;">**deleteRecords**</mark>**方法。这个方法可用于**<mark style="color:blue;">**删除指定偏移量之前的所有记录**</mark>，但它使用的是一种完全不同的机制。当这个方法被调用时，Kafka会将低水位标记（分区的第一个偏移量）移动到指定的偏移量。这样可以防止消费者读取低水位标记之前的记录，保证这些记录在被清理线程删除之前都是不可访问的。这个方法可用于删除设置了保留策略的主题和压实主题。
{% endhint %}

## 5.4.3 何时会压实主题

就像delete策略不会删除当前的活动片段一样，<mark style="color:blue;">**compact策略也不会压实当前的活动片段**</mark>，只有旧片段里的消息才会被压实。

**在默认情况下，Kafka会在主题中有50%的数据包含脏记录的情况下进行压实**。这样做的目的是避免压实太过频繁（因为压实会影响主题的读写性能），同时也能避免存在太多脏记录（因为它们会占用磁盘空间）。

管理员可以通过两个配置参数来控制压实时间：

* **min.compaction.lag.ms**：用于确保消息被写入之后最短需要经过多长时间才可以被压实。
*   **max.compaction.lag.ms**：用于确保消息从写入到可以被压实最长可以是多长时间。当业务要求在一定时间内进行压实时可以使用这个参数，例如，GDPR要求在收到删除请求之后30天内删除某些信息。

