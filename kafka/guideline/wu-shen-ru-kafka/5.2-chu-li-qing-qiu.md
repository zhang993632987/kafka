# 5.2 处理请求

<mark style="color:blue;">**broker会在它监听的每一个端口上运行一个接收器线程**</mark>，这个线程会创建一个<mark style="color:blue;">**连接**</mark>，并把它交给处理器线程处理。处理器线程（也叫网络线程）的数量是可配置的。<mark style="color:blue;">**网络线程负责从客户端获取请求，把它们放进请求队列，然后从响应队列取出响应，把它们发送给客户端。**</mark>

{% hint style="info" %}
**联想：**

在JUC中，submit一个任务后可以得到一个Future，通过该Future即可获取到处理结果，任务被放置在了工作任务队列中，由工作者线程异步处理。
{% endhint %}

有时候，服务器端需要延迟对客户端做出响应，例如，消费者要求只在有可用数据时接收响应，或者发出DeleteTopic请求的客户端要求在开始删除主题之后才接收响应。**延迟的响应会被放在炼狱（临时内存）中，直到它们可以被发送给客户端。**

**请求消息被放入请求队列后，IO 线程（也叫请求处理线程）会负责处理它们**。

<div align="left">

<figure><img src="../../../.gitbook/assets/处理请求.jpg" alt=""><figcaption></figcaption></figure>

</div>

<mark style="color:blue;">**生产请求和获取请求都必须发送给分区的首领**</mark>。如果broker收到一个针对某个分区的写入请求，而这个分区的首领在另一个broker上，那么发送请求的客户端将收到<mark style="color:blue;">**“非分区首领”错误**</mark>响应。如果针对某个分区的读取请求被发送到一个不包含这个分区首领的broker上，那么也会收到同样的错误。Kafka客户端负责把生产请求和获取请求发送到包含分区首领的broker上。

那么客户端怎么知道该向哪里发送请求呢？客户端使用了另一种请求类型，也就是<mark style="color:blue;">**元数据请求**</mark>，请求中包含了客户端感兴趣的主题清单。<mark style="color:blue;">**这种请求的响应消息里指明了这些主题所包含的分区、每个分区都有哪些副本，以及哪个副本是首领。元数据请求可以被发送给任意一个broker，因为所有broker都缓存了这些元数据信息。**</mark>

<mark style="color:orange;">一般情况下，</mark><mark style="color:orange;">**客户端会把这些信息缓存起来，并直接向目标broker发送生产请求和获取请求**</mark>。它们需要时不时地通过发送元数据请求来刷新缓存（刷新的时间间隔可以通过**metadata.max.age.ms**参数来配置），以便知道元数据是否发生了变化。**如果客户端收到“非分区首领”错误，那么它会在重新发送请求之前刷新元数据，因为这个错误说明客户端正在使用过期的元数据。**

## 5.2.1 生产请求

首先，包含某个**分区首领**的broker在收到生产请求时会对请求做一些验证。

* 发送数据的用户是否有主题写入**权限**？
* 请求中指定的**acks**是否有效（只允许出现0、1或all）？
* 如果acks=all，那么是否有**足够多的同步副本**保证消息可以被安全写入？

然后，消息将被写入本地磁盘。**在Linux系统中，消息会被写入文件系统缓存**，但**不能保证何时会被冲刷到磁盘上**。<mark style="color:orange;">**Kafka不会一直等待数据被持久化到磁盘上，它主要通过复制功能来保证消息的持久性。**</mark>

一旦消息被写入分区的首领，broker就会检查acks配置参数——如果acks是0或1，那么broker就会立即返回响应；如果acks是all，则请求将被保存在一个叫作**炼狱**的缓冲区中，直到首领确认跟随者副本复制了消息，才将响应返回给客户端。

## 5.2.2 获取请求

请求需要发送给指定的分区首领，所以客户端需要通过查询**元数据**来确保请求被路由到正确的节点上。首领在收到请求时会先检查请求是否有效，比如，指定的偏移量在分区中是否存在？如果客户端请求的数据已被删除，或者请求的偏移量不存在，则broker会返回错误。如果请求的偏移量存在，那么broker将按照客户端指定的数量上限从分区中读取消息，再把消息返回给客户端。

<mark style="color:blue;">**Kafka使用**</mark><mark style="color:red;">**零复制技术**</mark><mark style="color:blue;">**向客户端发送消息**</mark>，也就是说，<mark style="color:blue;">**Kafka会直接把消息从文件（或者更确切地说是Linux文件系统缓存）里发送到网络通道，不需要经过任何中间缓冲区**</mark>**。这项技术避免了字节复制，也不需要管理内存缓冲区，从而能够获得更好的性能**。这是Kafka与其他大部分数据库系统不一样的地方，其他数据库在将数据发送给客户端之前会先把它们保存在本地缓存中。

{% hint style="info" %}
除了可以设置broker返回数据的**上限**，客户端也可以设置broker返回数据的**下限**。如果把下限设置为10 KB，就好像是在告诉broker“等到有10 KB数据时再把它们返回给我”。**在主题消息流量不是很大的情况下，这样可以减少CPU和网络开销**。当然，我们不会一直让客户端等待broker累积数据。客户端可以在等待了一段时间之后就开始处理可用的数据，而不是一直等待下去。所以，客户端可以定义一个**超时时间**，告诉broker“如果你无法在x毫秒内累积足够多的数据，就把当前这些数据返回给我”。

客户端还可以指定**一个分区最多可以返回多少数据**。这个限制非常重要，因为客户端需要为broker返回的数据分配足够的内存。如果没有这个限制，并且broker返回了大量的数据，则可能会耗尽客户端的内存。
{% endhint %}

并不是所有保存在分区首领上的数据都可以被客户端读取。大部分客户端只能读取已经被写入所有同步副本 \[ 跟随者副本除外（尽管它们也是消费者），否则复制功能将无法正常工作 ] 的消息。分区首领知道哪些消息已经被复制到哪些副本上，所以**消息在还没有被写入所有同步副本之前是不会被发送给消费者的**——尝试获取这些消息的请求会得到空响应，而不是错误。

之所以这样，是因为还没有被足够多分区副本复制的消息被认为是“不安全”的——如果首领发生崩溃，另一个副本成为新首领，那么这些消息就丢失了。如果允许客户端读取只存在于首领中的消息，则可能会出现不一致的行为。所以，我们**会等到所有同步副本都复制了消息，才允许消费者读取它们**。这也意味着，<mark style="color:blue;">**如果broker间的消息复制因为某些原因变慢，那么消息到达消费者的时间也会变长（因为会先等待消息复制完毕）**</mark>。最大延迟时间可以通过参数**replica.lag.time.max.ms**来配置，它**指定了分区副本在复制消息时最多出现多长的延迟仍然被认为是同步的**。

{% hint style="info" %}
在某些情况下，消费者需要读取大量的分区。在每个发送给broker的请求中都包含整个分区清单并让broker返回所有的元数据的做法是非常低效的，因为分区及其元数据其实很少会发生变化。

为了最小化这种开销，**Kafka提供了请求会话缓存。**<mark style="color:blue;">**消费者可以尝试创建一个会话，会话中保存了它们正在读取的分区及其元数据信息。在创建了会话之后，消费者将不需要在每个请求中都指定分区，而是使用增量式请求。broker只会在分区及其元数据发生变化时才将它们包含在响应中**</mark><mark style="color:blue;">。</mark>

不过，会话缓存的空间是有限的，Kafka会优先保存需要处理大量分区的跟随者副本和消费者的会话，所以，**在某些情况下，broker可能不会创建会话，甚至会将会话清理掉**。对于这两种情况，broker将向客户端返回错误，客户端可以重新发起包含所有分区元数据的请求。
{% endhint %}
