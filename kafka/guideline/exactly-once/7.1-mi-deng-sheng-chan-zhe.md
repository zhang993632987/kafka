# 7.1 幂等生产者

<mark style="color:orange;">一个最典型的场景是分区首领收到生产者发送的一条消息，这条消息被跟随者成功复制，然后，首领所在的broker在向生产者发送响应之前崩溃了。生产者没有收到回应，在一段时间之后将重新发送消息。消息被发送给了新首领，而新首领已经有了上一次写入的消息副本，结果导致消息重复。</mark>

Kafka的幂等生产者可以自动检测并解决消息重复问题。

## 7.1.1 工作原理

**如果启用了幂等生产者，那么每条消息都将包含**<mark style="color:blue;">**生产者ID(PID)**</mark>**和**<mark style="color:blue;">**序列号**</mark>。我们**将它们与**<mark style="color:blue;">**目标主题**</mark>**和**<mark style="color:blue;">**分区**</mark>**组合在一起，用于唯一标识一条消息**。**broker会用这些唯一标识符跟踪写入每个分区的**<mark style="color:blue;">**最后5条消息**</mark>**。**<mark style="color:orange;">**为了减少每个分区需要跟踪的序列号数量，生产者需要将max.inflight.requests设置成5或更小的值（默认值是5）。**</mark>

**如果broker收到之前已经收到过的消息，那么它将拒绝这条消息，并返回错误。**生产者会记录这个错误，并反映在指标当中，但不抛出异常，也不触发告警。在生产者客户端，错误将被添加到record-error-rate指标当中。在broker端，错误是ErrorsPerSec指标的一部分。

如果broker收到一个非常大的序列号该怎么办？如果broker期望消息2后面跟着消息3，但收到了消息27，那么这个时候该怎么办？在这种情况下，broker将返回**“乱序”**错误。如果使用了不带事务的幂等生产者，则这个错误可能会被忽略。

### **1. 生产者重启**

当一个生产者发生故障时，我们通常会创建新生产者来代替它，如果启用了幂等生产者，那么**生产者在重启时就会连接broker并生成生产者ID**。生产者在每次初始化时都会产生一个新ID（假设没有启用事务）。**这意味着如果一个生产者发生故障，取代它的生产者发送了一条旧生产者已经发送过的消息，那么broker将无法检测到重复，因为这两条消息有不同的生产者ID和序列号，将被视为两条不同的消息。**需要注意的是，如果一个旧生产者被挂起，但在替代它的新生产者启动之后又“活”过来了，那么情况也一样——旧生产者不会被认为是“僵尸”，它们是两个拥有不同ID的生产者。

### **2. broker故障**

**当一个broker发生故障时，控制器将为首领副本位于这个broker上的分区选举新首领。**每次生成新消息时，首领都会用最后5个序列号更新内存中的生产者状态。每次从首领复制新消息时，跟随者副本都会更新自己的内存。当跟随者成为新首领时，它的内存中已经有了最新的序列号，并且可以继续验证新生成的消息，不会有任何问题或延迟。

如果旧首领又“活”过来了，会发生什么呢？在重启之后，内存中没有旧首领的生产者状态。为了能够恢复状态，每次在关闭或创建日志片段时broker都会将生产者状态快照保存到文件中。broker在启动时会从快照文件中读取最新状态，然后通过复制当前首领来更新生产者状态。当它准备好再次成为首领时，内存中已经有了最新的序列号。

如果broker发生崩溃，但没有更新最后一个快照，会发生什么呢？生产者ID和序列号也是Kafka消息格式的一部分。在进行故障恢复时，我们将通过读取旧快照和分区最新日志片段里的消息来恢复生产者状态。等故障恢复完成，一个新的快照就保存好了。

如果分区里没有消息，会发生什么呢？没有消息也就意味着没有重复消息。我们可以立即开始接收新消息（同时将状态缺失的警告信息记录下来），并创建生产者状态。

## 7.1.2 局限性

**幂等生产者只能防止由生产者内部重试逻辑引起的消息重复，不管这种重试是由生产者、网络还是broker错误所导致。**<mark style="color:blue;">**对于使用同一条消息调用两次producer.send()就会导致消息重复的情况，即使使用幂等生产者也无法避免。**</mark>这是因为生产者无法知道这两条消息实际上是一样的。

**应用程序有多个实例或一个实例有多个生产者的情况非常常见。如果两个生产者尝试发送同样的消息，则幂等生产者将无法检测到消息重复。**

## 7.1.3 如何使用幂等生产者

<mark style="color:blue;">**幂等生产者使用起来非常简单，只需在生产者配置中加入enable.idempotence=true。如果生产者已经配置了acks=all，那么在性能上就不会有任何差异。**</mark>

在启用了幂等生产者之后，会发生下面这些变化。

* 为了获取生产者ID，生产者在启动时会调用一个额外的API。
* 每个消息批次里的第一条消息都将包含**生产者ID**和**序列号**（批次里其他消息的序列号基于第一条消息的序列号递增）。这些新字段给每个消息批次增加了96位（生产者ID是长整型，序列号是整型），这对大多数工作负载来说几乎算不上是额外的开销。
* broker将会验证来自每一个生产者实例的序列号，并保证没有重复消息。
* 每个分区的消息顺序都将得到保证，即使**max.in.flight.requests.per.connection**被设置为大于1的值（5是默认值，这也是幂等生产者可以支持的最大值）。
