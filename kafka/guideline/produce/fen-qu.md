# 分区

**Kafka消息就是一个个的键–值对**，ProducerRecord对象可以只包含主题名称和值，键默认情况下是null。不过，大多数应用程序还是会用键来发送消息。键有两种用途：

* 一是作为消息的附加信息与消息保存在一起
* 二是用来确定消息应该被写入主题的哪个分区

<mark style="color:blue;">**如果键为null，并且使用了默认的分区器，那么记录将被随机发送给主题的分区**</mark>。

* 分区器使用<mark style="color:blue;">**轮询调度(round-robin)算法**</mark>将消息均衡地分布到各个分区中。
* 从Kafka 2.4开始，**在处理键为null的记录时，默认分区器使用的轮询调度算法具备了**<mark style="color:blue;">**黏性**</mark>。也就是说，<mark style="color:blue;">**在切换到下一个分区之前，它会将同一个批次的消息全部写入当前分区**</mark>**。**这样就可以使用更少的请求发送相同数量的消息，既降低了延迟，又减少了broker占用CPU的时间。

<mark style="color:blue;">**如果键不为空且使用了默认的分区器，那么Kafka会对键进行哈希**</mark>（使用Kafka自己的哈希算法，即使升级Java版本，哈希值也不会发生变化），<mark style="color:blue;">**然后根据哈希值把消息映射到特定的分区**</mark>。这里的关键在于同一个键总是被映射到同一个分区，所以**在进行映射时，会用到主题所有的分区，而不只是可用的分区**。这也意味着，如果在写入数据时目标分区不可用，那么就会出错。

> 除了默认的分区器，Kafka客户端还提供了**RoundRobinPartitioner**和**UniformStickyPartitioner**。在消息包含键的情况下，可以用它们来实现**随机分区**分配和**黏性随机**分区分配。
>
> 对某些应用程序（例如，ETL应用程序会将数据从Kafka加载到关系数据库中，并使用Kafka记录的键作为数据库的主键）来说，键很重要，但如果负载出现了倾斜，那么其中某些键就会对应较大的负载。这个时候，**可以用UniformStickyPartitioner将负载均衡地分布到所有分区。**
