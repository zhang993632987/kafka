# 轮询

<mark style="color:blue;">**消费者API最核心的东西是通过一个简单的轮询向服务器请求数据。**</mark>

* 像鲨鱼停止移动就会死掉一样，<mark style="color:blue;">**消费者必须持续对Kafka进行轮询，否则会被认为已经“死亡”**</mark>，它所消费的分区将被移交给群组里其他的消费者。
* **传给poll()的参数是一个超时时间间隔，用于控制poll()的阻塞时间**（当消费者缓冲区里没有可用数据时会发生阻塞）。如果这个参数被设置为0或者有可用的数据，那么poll()就会立即返回，否则它会等待指定的毫秒数。

> 在旧版本Kafka中，轮询方法的完整签名是poll(long)。现在，这个签名被弃用了，新API的签名是poll(Duration)。
>
> 除了参数类型发生变化，方法体里的阻塞语义也发生了细微的改变。
>
> * **原来的方法会一直阻塞，直到从Kafka获取所需的元数据，即使阻塞时间比指定的超时时间还长**。
> * **新方法将遵守超时限制，不会一直等待元数据返回**。
>
> 如果你已经有一个消费者使用poll(0) 来获取Kafka元数据（不消费任何记录，这是一种相当常见的做法），那么就不要指望把它改成poll(Duration.ofMillis(0)) 后还能获得同样的效果。你需要想新的办法来达到目的。**通常的解决办法是将逻辑放在rebalanceListener.onPartitionAssignment()方法里，这个方法一定会在获取分区元数据之后以及记录开始到达之前被调用。**

轮询不只是获取数据那么简单。

* **在第一次调用消费者的poll()方法时，它需要找到群组协调器，加入群组，并接收分配给它的分区**。
* 如果触发了再均衡，则整个**再均衡过程也会在轮询里进行**，包括执行相关的回调。

所以，消费者或回调里可能出现的错误最后都会转化成poll()方法抛出的异常。

需要注意的是，**如果超过max.poll.interval.ms没有调用poll()，则消费者将被认为已经“死亡”**，并被逐出消费者群组。因此，**要避免在轮询循环中做任何可能导致不可预知的阻塞的操作。**

{% hint style="info" %}
## <mark style="color:orange;">注意</mark>

既**不能在同一个线程中运行多个同属一个群组的消费者**，也**不能保证多个线程能够安全地共享一个消费者**。

按照规则，**一个消费者使用一个线程。**
{% endhint %}
