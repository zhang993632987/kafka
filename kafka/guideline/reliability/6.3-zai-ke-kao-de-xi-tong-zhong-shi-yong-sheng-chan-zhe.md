# 6.3 在可靠的系统中使用生产者

即使我们会尽可能地把broker配置得很可靠，但如果没有对生产者进行可靠性方面的配置，则整个系统仍然存在丢失数据的风险。

{% hint style="danger" %}
请看下面的两个例子。

* 我们**为broker配置了3个副本，并禁用了不彻底的首领选举**，这样应该可以保证已提交的消息不会丢失。不过，我们把**生产者发送消息的 acks 设置成了 1**。生产者向首领发送了一条消息，虽然其被首领成功写入，但其他同步副本还没有收到这条消息。首领向生产者发送了一个响应，告诉它“消息写入成功”，然后发生了崩溃，而此时其他副本还没有复制这条消息。另外两个副本此时仍然被认为是同步的，并且其中的一个副本会成为新首领。因为消息还没有被写入这两个副本，所以就丢失了，但发送消息的客户端认为消息已经成功写入。从消费者的角度来看，系统仍然是一致的，因为它们看不到丢失的消息（副本没有收到这条消息，不算已提交），但从生产者的角度来看，这条消息丢失了。
* 我们**为broker配置了3个副本，并禁用了不彻底的首领选举**。我们接受了之前的教训，把**生产者的 acks 设置成了 all**。假设现在生产者向Kafka发送了一条消息，此时分区首领刚好发生崩溃，新首领正在选举当中，Kafka会向生产者返回“首领不可用”的响应。在这个时候，如果生产者未能正确处理这个异常，也没有重试发送消息，那么消息也有可能丢失。这不算是broker的可靠性问题，因为broker并没有收到这条消息；这也不是一致性问题，因为消费者也不会读取到这条消息。问题在于，如果生产者未能正确处理异常，就有可能丢失数据。
{% endhint %}

从上面的两个例子可以看出，开发人员需要注意两件事情。

* <mark style="color:orange;">**根据可靠性需求配置恰当的 acks。**</mark>
* <mark style="color:orange;">**正确配置参数，并在代码里正确处理异常。**</mark>

## 6.3.1 发送确认

生产者可以选择以下3种确认模式：

* <mark style="color:blue;">**acks=0**</mark>：如果生产者能够通过网络把消息发送出去，那么就认为消息已成功写入Kafka。不过，在这种情况下仍然有可能出现错误，比如发送的消息对象无法被序列化或者网卡发生故障。如果此时分区离线、正在进行首领选举或整个集群长时间不可用，则并不会收到任何错误。**在 acks=0 模式下，生产延迟是很低的，但它对端到端延迟并不会带来任何改进（在消息被所有可用副本复制之前，消费者是看不到它们的）。**
* <mark style="color:blue;">**acks=1**</mark>：首领在收到消息并把它写入分区数据文件（不一定要冲刷到磁盘上）时会返回确认或错误响应。在这种模式下，如果首领被关闭或发生崩溃，那么那些已经成功写入并确认但还没有被跟随者复制的消息就丢失了。
* <mark style="color:blue;">**acks=all**</mark>：首领在返回确认或错误响应之前，会等待所有同步副本都收到消息。这个配置可以和 **min.insync.replicas** 参数结合起来，用于控制在返回确认响应前至少要有多少个副本收到消息。这是最安全的选项，因为生产者会一直重试，直到消息提交成功。

## 6.3.2 配置生产者的重试参数

生产者需要处理的错误包括两个部分：一部分是由生产者自动处理的错误，另一部分是需要开发者手动处理的错误。

<mark style="color:blue;">**生产者可以自动处理可重试的错误**</mark>。当生产者向broker发送消息时，broker可以返回一个成功响应或者错误响应。错误响应可以分为**两种**，一种是在**重试之后可以解决的**，另一种是**无法通过重试解决的**。如果broker返回 LEADER\_NOT\_AVAILABLE 错误，那么生产者可以尝试重新发送消息——或许新首领被选举出来了，那么第二次尝试发送就会成功。也就是说，LEADER\_NOT\_AVAILABLE 是一个**可重试**错误。如果broker返回 INVALID\_CONFIG 错误，那么即使重试发送消息也无法解决这个问题，所以这样的重试是没有意义的，这是**不可重试**错误。

一般来说，如果你的目标是不丢失消息，那么就让生产者在遇到可重试错误时保持重试。<mark style="color:orange;">**最好的重试方式是使用默认的重试次数（整型最大值或无限），并把 delivery.timeout.ms 配置成我们愿意等待的时长，生产者会在这个时间间隔内一直尝试发送消息。**</mark>

重试发送消息存在一定的风险，因为如果两条消息都成功写入，则会导致消息重复。通过重试和小心翼翼地处理异常，可以保证每一条消息都会被保存至少一次，但不能保证只保存一次。<mark style="color:blue;">**如果把 enable.idempotence 参数设置为 true，那么生产者就会在消息里加入一些额外的信息，broker可以使用这些信息来跳过因重试导致的重复消息。**</mark>

## 6.3.3 额外的错误处理

使用生产者内置的重试机制可以在不造成消息丢失的情况下轻松地处理大部分错误，但开发人员仍然需要处理以下这些其他类型的错误：

* **不可重试的broker错误**，比如消息大小错误、身份验证错误等。
* **在将消息发送给broker之前发生的错误**，比如序列化错误。
* **在生产者达到重试次数上限或重试消息占用的内存达到上限时发生的错误。**
* **超时。**

这些错误的处理逻辑与具体的应用程序及其目标有关——丢弃“不合法的消息”？把错误记录下来？停止从源系统读取消息？对源系统应用回压策略以便暂停发送消息？把消息保存到本地磁盘的某个目录里？具体使用哪一种逻辑要根据实际的架构和产品需求来决定。**只需记住，**<mark style="color:red;">**如果错误处理只是为了重试发送消息，那么最好还是使用生产者内置的重试机制。**</mark>
