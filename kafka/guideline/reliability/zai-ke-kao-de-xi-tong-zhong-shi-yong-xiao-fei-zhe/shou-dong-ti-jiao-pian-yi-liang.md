# 手动提交偏移量

如果想要更大的灵活性，选择了手动提交，那么就需要考虑**正确性**和**性能**方面的问题：

*   **总是在处理完消息后提交偏移量**

    在轮询过程中提交偏移量有一个缺点，就是有可能会意外提交已读取但未处理的消息的偏移量。一定要在处理完消息后再提交偏移量，这点很关键——提交已读取但未处理的消息的偏移量会导致消费者错过消息。
*   **提交频率是性能和重复消息数量之间的权衡**

    提交频率需要在性能需求和重复消息量之间取得平衡。处理一条消息就提交一次偏移量的方式只适用于吞吐量非常低的主题。
*   **再均衡**

    在设计应用程序时，需要考虑到消费者会发生再均衡并需要处理好它们。
*   **消费者可能需要重试**

    有时候，在调用了轮询方法之后，有些消息需要稍后再处理。需要注意的是，**消费者提交偏移量并不是对单条消息的“确认”**，这与传统的发布和订阅消息系统不一样。也就是说，**如果记录 #30处理失败，但记录 #31处理成功，那么就不应该提交记录 #31的偏移量——如果提交了，就表示 #31以内的记录都已处理完毕，包括记录 #30在内**，但这可能不是我们想要的结果。不过，可以采用以下两种模式来解决这个问题：

    * 第一种模式，在遇到可重试错误时，提交最后一条处理成功的消息的偏移量，然后把还未处理好的消息保存到缓冲区（这样下一个轮询就不会把它们覆盖掉），并调用消费者的 **pause()** 方法，确保其他的轮询不会返回数据，之后继续处理缓冲区里的消息。
    * 第二种模式，在遇到可重试错误时，把消息写到另一个**重试主题**，并继续处理其他消息。另一个消费者群组负责处理重试主题中的消息，或者让一个消费者同时订阅主主题和重试主题。这种模式有点儿像其他消息系统中的死信队列。
*   **消费者可能需要维护状态**

    在一些应用程序中，需要维护多个轮询之间的状态。如果想计算移动平均数，就需要在每次轮询之后更新结果。如果应用程序重启，则不仅需要从上一个偏移量位置开始处理消息，还需要恢复之前保存的移动平均数。**一种办法是在提交偏移量的同时把算好的移动平均数写到一个“结果”主题中。**当一个线程重新启动时，它就可以获取到之前算好的移动平均数，并从上一次提交的偏移量位置开始读取数据。

    一般来说，这是一个比较复杂的问题，建议尝试使用其他框架，比如Kafka Streams或Flink，它们为聚合、连接、时间窗和其他复杂的分析操作提供了高级的DSL API。
