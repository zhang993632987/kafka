# 生产者和消费者

## 生产者

<mark style="color:blue;">**生产者**</mark>创建消息。

* <mark style="color:blue;">**一条消息会被发布到一个特定的主题上**</mark>。
* 在默认情况下，生产者会把消息均衡地分布到主题的所有分区中。
  * 不过，在某些情况下，生产者会把消息直接写入指定的分区，这通常是通过消息<mark style="color:blue;">**键**</mark>和<mark style="color:blue;">**分区器**</mark>来实现的。**分区器会为键生成一个哈希值，并将其映射到指定的分区，这样可以保证包含同一个键的消息被写入同一个分区**。
  * 生产者也可以使用自定义的分区器，根据不同的业务规则将消息映射到不同的分区。

## **消费者**

<mark style="color:blue;">**消费者**</mark>读取消息。

* 消费者通过检查消息的<mark style="color:blue;">**偏移量**</mark>来区分已经读取过的消息。
  * <mark style="color:blue;">**偏移量**</mark>（不断递增的整数值）是另一种元数据，**在创建消息时，Kafka会把它添加到消息里**。
  * **在给定的分区中，每一条消息的偏移量都是唯一的**，越往后消息的偏移量越大（但不一定是严格单调递增）。
* **消费者会把每一个分区可能的下一个偏移量保存起来（通常保存在Kafka中），如果消费者关闭或重启，则其读取状态不会丢失**。

## 消费者群组

消费者可以是<mark style="color:blue;">**消费者群组**</mark>的一部分，<mark style="color:blue;">**属于同一群组的一个或多个消费者共同读取一个主题**</mark>。

* **群组可以保证每个分区只被这个群组里的一个消费者读取**。
  * 消费者与分区之间的映射通常被称为消费者对分区的所有权关系。
  * 通过这种方式，消费者可以读取包含大量消息的主题。
* 而且，**如果一个消费者失效，那么群组里的其他消费者可以接管失效消费者的工作**。
