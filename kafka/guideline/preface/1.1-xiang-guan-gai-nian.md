# 1.1 相关概念

Kafka是一款基于<mark style="color:blue;">**发布与订阅**</mark>模式的消息系统，一般被称为“<mark style="color:blue;">**分布式提交日志**</mark>”或“<mark style="color:blue;">**分布式流平台**</mark>”。

## 1 消息和批次

Kafka的数据单元被称为<mark style="color:blue;">**消息**</mark>。消息由<mark style="color:blue;">**字节数组**</mark>组成，对Kafka来说，消息里的数据没有特殊的格式或含义。消息可以有一个可选的元数据——<mark style="color:blue;">**键**</mark>，键也是一个字节数组，与消息一样，对Kafka来说没有特殊含义。当需要以一种可控的方式将消息写入不同的<mark style="color:blue;">**分区**</mark>时，需要用到键。最简单的例子就是为键生成一个一致性哈希值，然后用哈希值对主题分区数进行取模，为消息选取分区，这样可以保证具有相同键的消息总是会被写到相同的分区中（前提是分区数量没有发生变化）。

为了提高效率，消息会被分成批次写入Kafka。<mark style="color:blue;">**批次包含了一组属于同一个主题和分区的消息**</mark>。如果每一条消息都单独穿行于网络中，那么就会导致大量的网络开销，把消息分成批次传输可以减少网络开销。不过，这需要在时间延迟和吞吐量之间做出权衡：**批次越大，单位时间内处理的消息就越多，对单条消息来说，其传输时间就越长**。消息批次会被压缩，这样可以提升数据的传输和存储性能，但需要做更多的计算处理。

## 2 主题和分区

Kafka的消息通过**主题**进行分类。主题就好比数据库的表或文件系统的文件夹。<mark style="color:blue;">**主题可以被分为若干个分区，一个分区就是一个提交日志**</mark>。**消息会以**<mark style="color:blue;">**追加**</mark>**的方式被写入分区**，然后按照先入先出的顺序读取。需要注意的是，由于一个主题一般包含几个分区，因此<mark style="color:red;">**无法在整个主题范围内保证消息的顺序**</mark>，但<mark style="color:red;">**可以保证消息在单个分区内是有序的**</mark><mark style="color:red;">。</mark>

Kafka通过分区来实现数据的冗余和伸缩。分区可以分布在不同的服务器上，也就是说，一个主题可以横跨多台服务器，以此来提供比单台服务器更强大的性能。此外，<mark style="color:red;">**分区可以被复制，相同分区的多个副本可以保存在多台服务器上，以防其中一台服务器发生故障。**</mark>

## 3 生产者和消费者

生产者创建消息。一条消息会被发布到一个特定的主题上。在默认情况下，生产者会把消息均衡地分布到主题的所有分区中。不过，在某些情况下，生产者会把消息直接写入指定的分区，这通常是通过消息**键**和**分区器**来实现的。**分区器会为键生成一个哈希值，并将其映射到指定的分区，这样可以保证包含同一个键的消息被写入同一个分区**。生产者也可以使用自定义的分区器，根据不同的业务规则将消息映射到不同的分区。

消费者读取消息。消费者通过检查消息的偏移量来区分已经读取过的消息。<mark style="color:blue;">**偏移量**</mark>（不断递增的整数值）是另一种元数据，在创建消息时，Kafka会把它添加到消息里。在给定的分区中，每一条消息的偏移量都是唯一的，越往后消息的偏移量越大（但不一定是严格单调递增）。消费者会把每一个分区可能的下一个偏移量保存起来（通常保存在Kafka中），如果消费者关闭或重启，则其读取状态不会丢失。

消费者可以是<mark style="color:blue;">**消费者群组**</mark>的一部分，属于同一群组的一个或多个消费者共同读取一个主题。群组可以保证每个分区只被这个群组里的一个消费者读取。消费者与分区之间的映射通常被称为消费者对分区的所有权关系。通过这种方式，消费者可以读取包含大量消息的主题。而且，如果一个消费者失效，那么群组里的其他消费者可以接管失效消费者的工作。

## 4 broker和集群

一台单独的Kafka服务器被称为broker。broker会接收来自生产者的消息，为其设置偏移量，并提交到磁盘保存。broker会为消费者提供服务，对读取分区的请求做出响应，并返回已经发布的消息。

broker组成了集群。每个集群都有一个同时充当了集群控制器角色的broker（自动从活动的集群成员中选举出来）。<mark style="color:blue;">**控制器负责管理工作，包括为broker分配分区和监控broker**</mark>**。**在集群中，一个分区从属于一个broker，这个broker被称为分区的首领。一个被分配给其他broker的分区副本叫作这个分区的“跟随者”。分区复制提供了分区的消息冗余，如果一个broker发生故障，则其中的一个跟随者可以接管它的领导权。<mark style="color:blue;">**所有想要发布消息的生产者必须连接到首领**</mark><mark style="color:blue;">，但</mark><mark style="color:blue;">**消费者可以从首领或者跟随者那里读取消息**</mark><mark style="color:blue;">。</mark>

保留消息（在一定期限内）是Kafka的一个重要特性。<mark style="color:blue;">**broker默认的消息保留策略是这样的：要么保留一段时间（如7天），要么保留消息总量达到一定的字节数（如1 GB）**</mark>**。**当消息数量达到这些上限时，旧消息就会过期并被删除。所以，在任意时刻，可用消息的总量都不会超过配置参数所指定的大小。主题可以配置自己的保留策略，将消息保留到不再使用它们为止。我们可以把主题配置成<mark style="color:blue;">**紧凑型日志**</mark><mark style="color:blue;">，</mark><mark style="color:blue;">**只有最后一条带有特定键的消息会被保留下来。**</mark>

## 5 多集群

Kafka提供了一个叫作 <mark style="color:blue;">**MirrorMaker**</mark> 的工具，我们可以用它将数据复制到其他集群中。MirrorMaker的核心组件包括一个消费者和一个生产者，它们之间通过队列相连。消费者会从一个集群读取消息，生产者则会把消息发送到另一个集群中。
