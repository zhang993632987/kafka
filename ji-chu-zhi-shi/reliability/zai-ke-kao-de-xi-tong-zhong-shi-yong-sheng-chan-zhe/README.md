# 在可靠的系统中使用生产者

**即使我们会尽可能地把broker配置得很可靠，但如果没有对生产者进行可靠性方面的配置，则整个系统仍然存在丢失数据的风险。**

> ## 示例1：
>
> 我们**为broker配置了3个副本，并禁用了不彻底的首领选举**，这样应该可以保证已提交的消息不会丢失。不过，我们把**生产者发送消息的 acks 设置成了 1**。
>
> 1. 生产者向首领发送了一条消息，虽然其被首领成功写入，但其他同步副本还没有收到这条消息。
> 2. 首领向生产者发送了一个响应，告诉它“消息写入成功”，然后发生了崩溃，而此时其他副本还没有复制这条消息。另外两个副本此时仍然被认为是同步的，并且其中的一个副本会成为新首领。
> 3. 因为消息还没有被写入这两个副本，所以就丢失了，但发送消息的客户端认为消息已经成功写入。
>
> 从消费者的角度来看，系统仍然是一致的，因为它们看不到丢失的消息（副本没有收到这条消息，不算已提交），但从生产者的角度来看，这条消息丢失了。

> ## 示例2：
>
> 我们**为broker配置了3个副本，并禁用了不彻底的首领选举**。我们接受了之前的教训，把**生产者的 acks 设置成了 all**。
>
> * 假设现在生产者向Kafka发送了一条消息，此时分区首领刚好发生崩溃，新首领正在选举当中，Kafka会向生产者返回“首领不可用”的响应。
> * 在这个时候，如果生产者未能正确处理这个异常，也没有重试发送消息，那么消息也有可能丢失。
>
> 这不算是broker的可靠性问题，因为broker并没有收到这条消息；这也不是一致性问题，因为消费者也不会读取到这条消息。问题在于，如果生产者未能正确处理异常，就有可能丢失数据。

从上面的两个例子可以看出，开发人员需要注意两件事情。

* <mark style="color:orange;">**根据可靠性需求配置恰当的 acks。**</mark>
* <mark style="color:orange;">**正确配置参数，并在代码里正确处理异常。**</mark>
