# 事务可以解决哪些问题

假设有一个简单的流式处理应用程序：它**从源主题读取消息，然后可能会对消息做一些处理，再将结果写入另一个主题**。我们想要**确保处理的每一条消息的结果只被写入一次**。那么，哪些地方有可能出错呢？

### **应用程序崩溃导致的重复处理**

在从源集群读取并处理了消息之后，应用程序必须做两件事：

1. 一是**将结果写入输出主题**
2. 二是**提交已处理的消息的偏移量**。

假设这两个动作就按照这个顺序发生。**如果应用程序在发送结果之后发生崩溃，但偏移量还没有提交：**

几秒之后，因为没有心跳，所以将触发**再均衡**，消费者读取的分区将被重新分配给其他消费者。新消费者将从最后提交的偏移量的位置开始读取这些分区的消息。**在最后一个提交的偏移量和应用程序发生崩溃那个位置之间的消息将被再次处理，结果也将被再次写入输出主题——这就出现了重复。**

### **“僵尸”应用程序导致的重复处理**

如果应用程序从 Kafka 读取了一个消息批次，但还没有开始处理它们就被挂起或与 Kafka 断开了连接：

在停止发送心跳一段时间之后，应用程序将被认为已经“死亡”，它的分区将被重新分配给消费者群组里的其他消费者。新消费者将重新读取这个消息批次，对其进行处理，并将结果写入输出主题，然后继续。

这个时候，**之前的应用程序实例（被挂起的那个）可能又恢复过来了**：继续处理它最近读取的消息批次，并将结果写入输出主题。所有这些都可以在它“向Kafka轮询更多消息或发送心跳，然后发现它被认为已经“死亡”，并且现在有另外一个实例拥有这些分区”之前完成。

**一个“死亡”但不知道自己已经“死亡”的消费者被称为“僵尸”。**在这个场景中，如果没有额外的保证，则“僵尸”消费者可以向输出主题生成结果，进而导致重复。
