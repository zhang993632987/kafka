# 工作原理

**如果启用了幂等生产者，那么**<mark style="color:blue;">**每条消息都将包含生产者 ID(PID) 和序列号，将它们与目标主题和分区组合在一起，用于唯一标识一条消息**</mark>。**broker 会用这些唯一标识符跟踪写入每个分区的**<mark style="color:blue;">**最后 5 条消息**</mark>**。**<mark style="color:orange;">**为了减少每个分区需要跟踪的序列号数量，生产者需要将 max.inflight.requests 设置成 5 或更小的值（默认值是 5）。**</mark>

**如果 broker 收到之前已经收到过的消息，那么它将拒绝这条消息，并返回错误。**

## **生产者重启**

当一个生产者发生故障时，我们通常会创建新生产者来代替它，如果启用了幂等生产者，那么**生产者在重启时就会连接 broker 并生成生产者 ID**。

生产者在每次初始化时都会产生一个新 ID（假设没有启用事务）。这意味着<mark style="color:orange;">**如果一个生产者发生故障，取代它的生产者发送了一条旧生产者已经发送过的消息，那么 broker 将无法检测到重复，因为这两条消息有不同的生产者 ID 和序列号，将被视为两条不同的消息。**</mark>

## **broker故障**

**当一个 broker 发生故障时，控制器将为首领副本位于这个 broker 上的所有分区选举新首领。**每次生成新消息时，首领都会用最后 5 个序列号更新内存中的生产者状态。每次从首领复制新消息时，跟随者副本都会更新自己的内存。因此，**当跟随者成为新首领时，它的内存中已经有了最新的序列号，并且可以继续验证新生成的消息，不会有任何问题或延迟。**

1.  如果旧首领又“活”过来了，会发生什么呢？[^1]

    在重启之后，内存中没有旧首领的生产者状态。为了能够恢复状态，每次在关闭或创建日志片段时  broker 都会将生产者状态快照保存到文件中。broker 在启动时会从快照文件中读取最新状态，然后通过复制当前首领来更新生产者状态。当它准备好再次成为首领时，内存中已经有了最新的序列号。
2.  [如果 broker 发生崩溃，但没有更新最后一个快照，会发生什么呢？](#user-content-fn-2)[^2]

    生产者 ID 和序列号也是 Kafka 消息格式的一部分。**在进行故障恢复时，将通过读取旧快照和分区最新日志片段里的消息来恢复生产者状态。**等故障恢复完成，一个新的快照就保存好了。
3.  如果分区里没有消息，会发生什么呢？

    没有消息也就意味着没有重复消息，因此可以立即开始接收新消息（同时将状态缺失的警告信息记录下来），并创建生产者状态。

[^1]: 未触发首领选取的前提下才有讨论的价值

[^2]: 未触发首领选取的前提下才有讨论的价值
