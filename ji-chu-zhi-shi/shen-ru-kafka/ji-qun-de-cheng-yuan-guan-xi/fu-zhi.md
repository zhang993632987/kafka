# 复制

复制是 Kafka 架构核心的一部分。Kafka 经常被描述成“一个分布式、分区、可复制的提交日志服务”。**复制**之所以这么重要，是因为它**可以在个别节点失效时仍能保证 Kafka 的可用性和持久性**。

<mark style="color:blue;">**Kafka 的数据保存在主题中，每个主题被分成若干个分区，每个分区可以有多个副本。副本保存在 broker 上，每个 broker 可以保存成百上千个主题和分区的副本。**</mark>

## 首领副本与跟随者副本

副本有以下两种类型：

* <mark style="color:blue;">**首领副本**</mark>**：每个分区都有一个首领副本**。
  * **为了保证一致性，所有生产者请求和消费者请求都会经过这个副本**。
  * **客户端可以从首领副本或跟随者副本读取数据**。
* <mark style="color:blue;">**跟随者副本**</mark>**：首领以外的副本都是跟随者副本。**
  * **如果没有特别指定，跟随者副本将不处理来自客户端的请求，它们的主要任务是从首领那里复制消息，保持与首领一致的状态**。
  * **如果首领发生崩溃，那么其中的一个跟随者就会被提拔为新首领。**

{% hint style="info" %}
<mark style="background-color:green;">**从跟随者副本读取数据**</mark>

**这个特性的主要目的是允许客户端从最近的同步副本而不是首领副本读取数据，以此来降低网络流量成本。**

要使用这个特性：

* <mark style="color:blue;">**消费者端需要配置可以标识客户端位置的 client.rack。**</mark>
* <mark style="color:blue;">**broker 端需要配置 replica.selector.class，把它设置为 RackAwareReplicaSelector**</mark>。它将选择一个**最近的副本，这个副本所在的 broker 的 rack.id 与客户端配置的 client.rack 相匹配**。默认为 LeaderSelector，表示总是从首领副本读取数据。

Kafka 的复制协议经过了扩展，保证<mark style="color:orange;">**从跟随者副本读取的消息都是已提交的**</mark>。也就是说，即使是从跟随者副本读取数据，仍然可以获得与之前一样的可靠性保证。**为了提供这种保证，所有副本都需要知道首领提交了哪些消息。**

为此，<mark style="color:blue;">**首领在发送给跟随者的数据中加入了当前高水位标记（最近提交的偏移量）**</mark>。**传输高水位标记会导致一些延迟，也就是说，**<mark style="color:blue;">**从跟随者副本读取到可用数据将比从首领副本读取晚一些**</mark>。如果要减少消费者延迟，则需要从首领副本读取数据。
{% endhint %}

## 同步副本

**首领的另一项任务是搞清楚哪些跟随者副本的状态与自己是一致的**。

**为了与首领保持同步，跟随者需要向首领发送 Fetch 请求，这与消费者为了读取消息而发送的请求是一样的**。作为响应，首领会将消息返回给跟随者。Fetch 请求消息里包含了跟随者想要获取的消息的偏移量，这些偏移量总是有序的。这样，首领就可以知道一个副本是否已经获取了最近一条消息之前的所有消息。

通过检查每个副本请求的最后一个偏移量，首领就可以知道每个副本的滞后程度。**如果副本没有在 30 秒内发送请求，或者即使发送了请求但与最新消息的间隔超过了 30 秒，那么它将被认为是不同步的**。如果一个副本未能跟上首领，那么一旦首领发生故障，它将不能再成为新首领——毕竟，它并未拥有所有的消息。

与此相反，持续发出获取最新消息请求的副本被称为<mark style="color:blue;">**同步副本**</mark>。**当首领发生故障时，只有同步副本才有资格被选为新首领。**

**允许跟随者可以多久不活跃或允许跟随者在多久之后成为不同步副本是通过 replica.lag.time.max.ms 参数来配置的**。这个时间直接影响首领选举期间的客户端行为和数据保留机制。

## 首选首领

除了当前的首领，每个分区都有一个<mark style="color:blue;">**首选首领，即创建主题时选定的首领**</mark>。之所以是首选的，是因为[<mark style="color:blue;">**在创建分区时，分区首领在 broker 间的分布已经是均衡的**</mark>](../wu-li-cun-chu/fen-qu-de-fen-pei.md)<mark style="color:blue;">**，**</mark>我们希望当首选首领成为当前首领时，broker 之间的负载是均衡的。

在默认情况下，Kafka 的 **auto.leader.rebalance.enable** 会被设置为 true，它会检查首选首领是不是当前首领以及是不是同步的。如果是同步的，但不是当前首领，就会触发首领选举，让首选首领成为当前首领。

{% hint style="info" %}
可以很容易地从分区的副本列表中找到首选首领，可以用 **kafka-topics.sh** 查看分区和副本的详细信息，**列表中的第一个副本一般就是首选首领，不管当前首领是哪一个副本**，或者使用副本分配工具将副本重新分配给了其他 broker，这一点都不会改变。

**需要注意的是，如果你手动重新分配了副本，那么第一个指定的副本就是首选首领。**

<mark style="color:orange;">**要确保首选首领被分配给不同的 broker，避免出现少部分包含了首领的 broker 负载过重，其他 broker 无法为它们分担负载的情况。**</mark>
{% endhint %}
