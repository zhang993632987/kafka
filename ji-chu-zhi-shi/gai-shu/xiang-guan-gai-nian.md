# 相关概念

## 消息和批次

Kafka 的数据单元被称为<mark style="color:blue;">**消息**</mark>。

* **消息由**<mark style="color:blue;">**字节数组**</mark>**组成**，对 Kafka 来说，消息里的数据没有特殊的格式或含义。
*   **消息可以有一个可选的元数据——**<mark style="color:blue;">**键**</mark>**，键也是一个字节数组**，与消息一样，对 Kafka 来说没有特殊含义。**当需要以一种可控的方式将消息写入不同的**<mark style="color:blue;">**分区**</mark>**时，需要用到键**。

    最简单的例子就是为键生成一个一致性哈希值，然后用哈希值对主题分区数进行取模，为消息选取分区，这样可以保证具有相同键的消息总是会被写到相同的分区中（前提是分区数量没有发生变化）。

<mark style="color:blue;">**为了提高效率，消息会被分成批次写入 Kafka。批次包含了一组属于同一个主题和分区的消息**</mark>。

如果每一条消息都单独穿行于网络中，那么就会导致大量的网络开销，把消息分成批次传输可以减少网络开销。不过，这**需要在时间延迟和吞吐量之间做出权衡：批次越大，单位时间内处理的消息就越多，对单条消息来说，其传输时间就越长。**

**消息批次可以被压缩**，这样可以提升数据的传输和存储性能，但需要做更多的计算处理。

## 主题和分区

Kafka 的消息通过**主题**进行分类（**主题就好比数据库的表或文件系统的文件夹**）。

* <mark style="color:blue;">**主题可以被分为若干个分区，一个分区就是一个提交日志**</mark>。
* **消息会以**<mark style="color:blue;">**追加**</mark>**的方式被写入分区，然后按照先入先出的顺序读取。**

{% hint style="warning" %}
## <mark style="color:orange;">注意</mark>

<mark style="color:orange;">**由于一个主题一般包含几个分区，因此无法在整个主题范围内保证消息的顺序。但可以保证消息在单个分区内是有序的。**</mark>
{% endhint %}

<mark style="color:blue;">**Kafka 通过分区来实现数据的冗余和伸缩。**</mark>

* 分区可以分布在不同的服务器上，也就是说，**一个主题可以横跨多台服务器，以此来提供比单台服务器更强大的性能。**
* 此外，<mark style="color:blue;">**分区可以被复制，相同分区的多个副本可以保存在多台服务器上，以防其中一台服务器发生故障。**</mark>

## 生产者和消费者

<mark style="color:blue;">**生产者**</mark>创建消息，<mark style="color:blue;">**一条消息会被发布到一个特定的主题上**</mark>。

* 在默认情况下，生产者会把消息均衡地分布到主题的所有分区中。
* 不过，在某些情况下，生产者会把消息直接写入指定的分区，这通常是通过消息<mark style="color:blue;">**键**</mark>和<mark style="color:blue;">**分区器**</mark>来实现的。**分区器会为键生成一个哈希值，并将其映射到指定的分区，这样可以保证包含同一个键的消息被写入同一个分区**。
* 生产者也可以使用自定义的分区器，根据不同的业务规则将消息映射到不同的分区。

<mark style="color:blue;">**消费者**</mark>读取消息，消费者通过检查消息的<mark style="color:blue;">**偏移量**</mark>来区分已经读取过的消息。

* <mark style="color:blue;">**偏移量**</mark>（不断递增的整数值）是另一种元数据，**在创建消息时，Kafka会把它添加到消息里**。
* **在给定的分区中，每一条消息的偏移量都是唯一的**，越往后消息的偏移量越大（但不一定是严格单调递增）。
* **消费者会把每一个分区可能的下一个偏移量保存起来（通常保存在 Kafka 中），如果消费者关闭或重启，则其读取状态不会丢失**。

消费者可以是<mark style="color:blue;">**消费者群组**</mark>的一部分，<mark style="color:blue;">**属于同一群组的一个或多个消费者共同读取一个主题**</mark>。

* **群组可以保证每个分区只被这个群组里的一个消费者读取**。消费者与分区之间的映射通常被称为消费者对分区的所有权关系。通过这种方式，消费者可以读取包含大量消息的主题。
* 而且，**如果一个消费者失效，那么群组里的其他消费者可以接管失效消费者的工作**。

## broker和集群

一台单独的 Kafka 服务器被称为 <mark style="color:blue;">**broker**</mark>。

* broker 会**接收来自生产者的消息**，为其**设置偏移量**，并**提交到**<mark style="color:blue;">**磁盘**</mark>**保存**。
* broker 会**为消费者提供服务**，对**读取分区的请求做出响应**，并**返回已经发布的消息**。

broker 组成了集群。每个集群都有一个同时充当了**集群控制器**角色的 broker（自动从活动的集群成员中选举出来）。<mark style="color:blue;">**控制器负责管理工作，包括为 broker 分配分区和监控 broker**</mark>**。**

**在集群中，一个分区从属于一个 broker，这个 broker 被称为分区的首领**。**一个被分配给其他 broker 的分区副本叫作这个分区的“跟随者”。分区复制提供了分区的消息冗余，如果一个 broker 发生故障，则其中的一个跟随者可以接管它的领导权。**

> <mark style="color:blue;">**所有想要发布消息的生产者必须连接到首领**</mark><mark style="color:blue;">，</mark>但<mark style="color:blue;">**消费者可以从首领或者跟随者那里读取消息**</mark><mark style="color:blue;">。</mark>

<mark style="color:blue;">**保留消息**</mark>（在一定期限内）是 Kafka 的一个重要特性。

* <mark style="color:blue;">**broker 默认的消息保留策略是这样的：要么保留一段时间（如 7 天），要么保留消息总量达到一定的字节数（如 1 GB）**</mark>**。**当消息数量达到这些上限时，旧消息就会过期并被删除。
* <mark style="color:blue;">**主题可以配置自己的保留策略**</mark>，将消息保留到不再使用它们为止。
* 可以把主题配置成<mark style="color:blue;">**紧凑型日志**</mark><mark style="color:blue;">，</mark><mark style="color:blue;">**只有最后一条带有特定键的消息会被保留下来。**</mark>

## 多集群

Kafka 提供了一个叫作 <mark style="color:blue;">**MirrorMaker**</mark> 的工具，**可以用它将数据复制到其他集群中**。

MirrorMaker 的**核心组件**包括一个**消费者**和一个**生产者**，它们之间通过队列相连。

* **消费者会从一个集群读取消息**
* **生产者则会把消息发送到另一个集群中**
